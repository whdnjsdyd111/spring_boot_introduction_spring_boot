        설정 클래스와 Bean 이용

지금까지 다양한 Bean 을 사용해왔다. 스프링 부트에선 컨트롤러, 모델, 서비스, 리포지터리 등 다수의 클래스를
만들어서 그 안에서 @Autowired 등을 사용해 Bean 을 바인딩했었다. 지금까지 만들었던 예제를 보면
스프링 부트에선 'Bean 을 얼마나 잘 활용하는가' 가 매우 중요하다는 것을 알 수 있다.

스프링 프레임워크나 스프링 부트 애플리케이션에서 표준으로 사용할 수 있는 Bean 이 있지만, 개발자가 직접 만든 클래스를
Bean 으로 사용해야 하는 경우도 있다. 이런 경우 지금까지는 '컴포넌트' 나 '서비스' 로 만들었다.

사실은 이런 형태가 아니고 일반적인 클래스라도 Bean 으로 애플리케이션에 등록해서 컨트롤러 등 다양한 곳에서
이용할 수도 있다. 이때 사용하는 것이 스프링 프레임워크의 '설정 클래스' 다.

    설정 클래스는 '설정 파일' 의 클래스 버전

프레임워크에선 다양한 설정 정보를 파일 형태로 보관하는 것이 일반적이다. 대부분은 XML 파일이나 프로퍼티 파일을 사용하며,
미리 설정이 필요한 항목을 파일에 기록해두고 그 파일을 애플리케이션 내에서 읽어서 사용하는 방식이다.
지금까지 스프링 부트를 사용해오면서 이런 설정 파일을 전혀 다루지 않았다는 것을 눈치 챘을 것이다.
설정 파일과 비슷한 것으로 pom.xml 파일이 있지만, 이것도 애플리케이션을 빌드할 때 사용하는 빌드 툴(메이븐) 전용 파일로
스프링 부트 애플리케이션의 설정 파일이 아니다. '스프링 부트에선 설정 파일이 없는 것인가' 하고 생각하는 사람도
있을 것이다. 물론 스프링 부트에도 초기 설정을 위한 구조가 있다. 다만 파일이 아닌 '클래스' 형태다.
설정을 위한 클래스를 만들어서 스프링 부트 애플리케이션에 각종 Bean 을 설정할 수 있게 된다.

        설정 클래스 만들기

간단한 설정 파일을 만들어보자.

    MyBootAppConfig.java

설정 클래스는 아무런 클래스도 상속하지 않는 매우 일반적인 POJO 클래스다. 단지 클래스 앞에 @Configuration 어노테이션을
붙이고 있다. 이것은 애플리케이션 실행 시에 이 클래스가 설정 클래스로 인스턴스화되고 여기에 기술된
Bean 등도 애플리케이션에 등록하는 역할을 한다.

        Bean 클래스 만들기

다음은 Bean 클래스를 만들어보자.

    MyDataBean.java

MyDataRepository 를 이용해서 지정한 ID 의 MyData 를 불러오고 그것을 테이블의 <tr><td> 태그 형태로 출력하는
기능을 제공한다. getTableTagById 메소드 자체는 단순히 MyDataRepository 의 findOne 메소드를 호출한 결과를
HTML 태그의 텍스트로 변환하는 것이다.
이 클래스는 아무런 클래스를 상속하고 있지 않으며 어노테이션 등도 없다. '단순한 POJO 클래스' 인 것이다.
@Component 도 없고 @Service 도 지정하고 있지 않다. 이 상태로는 애플리케이션 내에서 Bean 으로 사용할 수 없다.

        Bean 으로 등록해서 사용하기

그러면 작성한 MyDataBean 을 설정 클래스로 Bean 으로 등록해보자.
MyBootAppConfig 클래스를 열어서 다음과 같이 수정한다.

    MyBootAppConfig03.java

@Autowired 를 사용해서 MyDataBean 필드에 인스턴스를 자동 설정하고 있다.
또한, 쿼리 스트링으로 전달된 값을 사용해ㅐ서 MyDataBean 의 getTableTagById 메소드를 호출하고 그 결과를
data 에 저장하고 있다.
MyDataBean 이 애플리케이션에 Bean 으로 설정돼 있는 경우 @Autowired 를 설정하면 해당 인스턴스가 자동으로
바인딩되는 것이다.

    템플릿 작성

여기선 웹 화면 표시를 위해 pickup 템플릿을 지정하고 있다. 이 템플릿을 작성해보자.

    pickup.html

<p th:utext="${data}"> 라고 해서 data 의 내용을 이스케이프하지 않고 출력하고 있다.
컨트롤러에선 mav.addObject("data", table) 과 같이 테이블의 HTML 태그를 설정하고 있으므로
이것이 그대로 <p> 태그에 출력되는 것이다.
완료했으면 /1 과 같이 번호를 붙여서 접속해보자. 해당 번호의 데이터가 테이블 형태로 표시된다.
컨트롤러에 @Autowired 된 MyDataBean 이 제대로 동작하는 것을 확인할 수 있다.

        페이지 매김에 대해

대량의 데이터를 처리하는 경우 '항상 모든 데이터를 표시' 하는 것은 어렵다. 수만 개 또는 수십만 개의 데이터가
데이터베이스에 저장돼 있는 경우, 데이터 일부만 추출해서 순서대로 표시하는 '페이지 매김' 방식이 필요하다.
이렇게 페이지를 나누어 데이터를 처리하는 기능을 페이지 매김(페이지네이션) 이라고 한다.
그러면 스프링 부트에서 페이지 매김 기능을 사용하려면 어떻게 해야 할까?
스프링 프레임워크에는 페이지 매김을 위한 Page 클래스가 있다. 이것을 사용해서 페이지 매김 처리를 구현할 수 있다.
실제로 사용해보자.

    페이지를 나누어 엔터티 가져오기

먼저 페이지 단위로 엔터티를 가져오는 메소드를 작성해보자. 여기선 코드 MyDataService 클레스에 서비스로 메소드를 설정한다.
MyDataService 클래스 안에 다음 메소드를 추가하자.

    MyDataService04.java

비교적 단순하다.

    PageRequest 인스턴스 만들기


    PageRequest pageRequest = new PageRequest(pageNumber - 1, PAGE_SIZE);


제일 먼저 하는 것은 PageRequest 라는 클래스의 인스턴스를 만드는 것이다.
이것은 페이지 번호와 페이지 크기(한 페이지당 엔터티 수)를 인수로 지정해서 new 하는 것이다.
이 PageRequest 를 사용해서 페이지 정보를 관리하는 것이다.

    findAll 로 엔터티 가져오기


    return repository.findAll(pageRequest);


MyDataRepository 의 findAll 메소드를 호출해서 엔터티를 추출한다. 하지만 보통 때와는 달리 인수에는
PageRequest 인스턴스를 지정한다. 이렇게 해서 PageRequest 에서 정한 규칙에 따라 페이지를 나눈 엔터티가 추출되게 된다.
반환값은 List 가 아닌 Page 클래스의 인스턴스가 된다. 이 Page 는 List 의 서브 클래스인 컬렉션 클래스로 페이지 매김한
엔터티를 저장하기 위해 사용된다. 이렇게만 설정하면 페이지가 나뉜 엔터티를 가져올 수 있다.
생각보다 간단하다.

    리퀘스트 핸들러 작성

이 MyDataService 에 작성한 메소드를 사용하게끔 컨트롤러의 리퀘스트 핸들러를 만들어보자.
다음 메소드를 HeloController 클래스에 추가한다.

    HeloController05.java

"/page/{num}" 이라는 형태로 리퀘스트 매핑을 하고 있다. 페이지 번호를 주소 끝에 붙여서 접속하면 해당 페이지 번호의
엔터티가 표시되는 것이다. 여기선,


    Page<MyData> page = service.getMyDataInPage(num);


이와 같이 getMyDataInPage 를 호출해서 Page 인스턴스를 추출하고 있다. 이것을 datalist 라는 이름으로
저장해서 템플릿으로 표시한다.

    템플릿 수정

index.html 에선 테이블로 datalist 의 데이터를 표시하게 되어 있다.
데이터 목록 표시 부분이 다음과 같이 돼 있는데, <script> 태그로 작성한 자바스크립트를 제거하자.

    index02.html

Page 인스턴스가 datalist 에 저장되므로 이 상태로도 문제없이 엔터티가 테이블에 표시된다.
Page 는 List 의 서브 클래스이므로 List 와 동일한 방식으로 출력할 수 있다.
결과적으로 페이지 매김 기능 구현은 이것으로 전부다. 생각보다 쉽다.

        타임리프의 유틸리티 객체

페이지 매김이라는 것은 '페이지를 나눈 엔터티를 가져오면 그것으로 끝' 이 아니다.
페이지를 앞뒤로 이동하는 등 페이지 표시에 관련된 기능을 만들어야 한다.
"page/번호" 라는 형태로 접속하면 해당 페이지가 표시되는 기능을 구현했다. 따라서 이것을 이용해서 앞뒤 페이지로
이동하는 링크는 쉽게 만들 수 있다. "/page/페이지번호 + 1" 과 같은 형태로 주소를 지정하면
다음 페이지의 링크가 만들어진다. 하지만 이 방법은 이해하기 어려운 식을 설정해야 하고 유지관리도 불편해서
그다기 좋은 방법은 되지 못한다. 이런 경우에는 타임리프에 있는 '유틸리티 객체' 를 사용하는 것이 좋다.
유틸리티 객체란 타임리프 내에서 사용할 수 있는 특별한 객체다. 자바 클래스로 정의하고
타임리프 내에서 해당 클래스의 내부 메소드를 호출해서 그 결과를 출력할 수 있다.
이 유틸리티 객체를 사용하기 위해서는 유틸리티 객체 클래스와 'Dialect 클래스' 를 준비해야 한다.

    유틸리티 객체 클래스 작성

먼저 유틸리티 객체 클래스를 만든다. 이것은 일반적인 자바 클래스로 만든다.

    MyTLUtility.java

여기선 세 개의 메소드를 설정하고 있다. hello 는 유틸리티 객체의 샘플 메소드이고, 실제로 사용하는 것은 prevUrl, nextUrl
이다. 각각 앞 페이지의 주소와 뒷 페이지의 주소를 반환한다. 유틸리티 객체는 이와 같이 '출력할 텍스트를 반환' 하는
형태로 작성한다 여기서 반환되는 내용이 템플릿 측에서 표시되는 것이다.

    Dialect 클래스 작성

계속해서 Dialect 클래스를 작성하자.

    MyTLDialect.java

Dialect 클래스는 AbstractDialect 클래스의 서브 클래스로 작성한다. 또한, IExpressionEnhancingDialect 라는
인터페이스를 implements 한다. 이 인터페이스에는 getAdditionalExpressionObject 와 getPrefix 라는 메소드가 존재하며
이들을 반드시 구현해두어야 한다.


    static {
        Map<String, Object> objects = new HashMap<>();
        objects.put("myTLHelper", new MyTLUtility());
        EXPRESSION_OBJECT = Collections.unmodifiableMap(objects);
    }


objects.put("myTLHelper", new MyTLUtility()); 라는 것이 MyTLUtility 의 인스턴스를 'myTLHelper' 라는 이름으로
등록하고 있는 부분이다. 이 부분을 제외한 코드는 위에 있는 예제 코드를 그대로 배껴 사용하면 된다.
어떤 유틸리티 객체라도 동일하게 작성할 수 있다.
MyBootAppConfig.java 에는 다음 메소드를 추가해야 한다.

    MyBootAppConfig06.java


    <a th:href="${#myTLHelper.prevUrl(pagenumber)}"><- Prev</a>


이와 같이 기술돼 있는데, 여기선 '#myTLHelper' 라는 형태로 유틸리티 객체 myTLHelper 가 사용되고 있다.
유틸리티 객체는 이처럼 '#이름' 형태로 호출할 수 있다.
여기선 단순히 앞뒤 페이지로 이동하는 링크를 만들었지만 <a> 태그 자체를 출력하는 메소드를 만드는 것도 좋다.
이때 앞뒤 페이지가 더는 존재하지 않는 경우 링크가 표시되지 않게 하면 사용이 더 편리해질 것이다.